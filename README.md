# neo4j-courses
这是 CS3321 数据库最终项目的子模块。该仓库充当我们的项目 Course-Stack 知识图谱后端.
有关 Course-Stack 的更多信息，请参阅我们的[主要仓库](https://github.com/Simonwzm/CS3321-Course-Stack)。

# 使用指南

## Docker安装(推荐)

1.
```shell=bash
docker build -t courses .
```

2.
```shell=bash
docker run -d -p 8080:8000 --name courses courses 
```

请移步https://localhost:8080 进行操作.

## 本地环境配置
1. 创建conda环境
```shell=zsh
conda create --name neo4j-courses python=3.8
```


2. 安装所需依赖
```shell=bash
pip install -r requirements.txt
```

3. 建立数据库

```shell=bash
 ./build-neo4j-instances.sh neo4j_prompts
 ```
这会默认使用一些端口,如果遇到问题的话请优先查看端口是否被占用:`sudo lsof -i -P -n | grep LISTEN`,占用端口的范围是7474~7484.

4. 使用uvicorn运行FastAPI

```shell=bash
 python courses_async_post.py --port 8000 --database_dir $HOME/neo4j-instances/ --host "127.0.0.1"
```

请移步https://localhost:8080 进行操作. 如果启动应用后发现没法正常访问api说明中的端点,请查看是否所有的neo4j实例已经启动,可以通过端口查询,如果没有正常启动的话,可以先`cd`到`$HOME/neo4j-instances/ports/`目录,然后运行`ls | xargs -I{} /bin/bash -c "cd {};./bin/neo4j start;cd -;"`.


# 知识图谱需求设计文档:

## 系统目的和范围扩展

本系统旨在打造一个全面的知识图谱管理系统，通过集成先进的文本处理和大数据分析技术，为教学和学习过程提供支持。该系统能够帮助学生探索学科间的深层关联，优化他们的学习路径。

## 用户角色和交互

* 学生：
    - 功能：浏览课程图谱，提交课程反馈，自定义学习路径，接收课程推荐。
    - 场景示例：学生可以查询课程的先修关系，根据个人兴趣和学习历史定制学习路径。
* 教师：
    - 功能：上传和编辑课程资料，查看学生反馈，分析课程互动数据，创建和维护课程知识图谱。
    - 场景示例：教师可以更新课程大纲，分析学生的学习效果，根据学生的表现调整教学方法。
    
## 功能需求详细化

* 课程管理系统：实现课程的增加、删除、修改和查询支持批量上传课程资料及更新。
* 知识图谱交互与生成：动态生成课程的知识图谱，包括课程之间的依赖关系和知识点链接。提供交互式图谱探索工具，支持用户按需调整和查看不同视图。
* 个性化学习路径推荐：根据学生的学习历史和成绩，以及课程间的逻辑关系，自动生成个性化学习建议。实时更新学习推荐，反映最新的学习进度和课程调整。

## 性能和系统约束

* 扩展性：系统设计应支持大规模并发访问，预留扩展接口以适应未来新功能的添加。
* 安全性：实现基于角色的访问控制，确保数据的加密传输和存储，定期进行安全审计。

## 数据字典

* 查询处理器（QP）：处理来自用户界面的查询请求，与课程数据库进行交互。
* 课程数据库（DB）：存储所有课程相关数据，如课程详情、教师信息和学习资料。
* 知识图谱引擎（KG）：负责根据课程数据生成和更新知识图谱。
* 图谱数据库（GDB）：专门存储知识图谱数据，支持高效的图谱查询。
* 更新处理器（UP）：处理来自用户界面的课程数据更新请求。
* 权限管理（AM）：管理用户权限，执行身份验证和访问控制。

## 数据流图

<img src="https://notes.sjtu.edu.cn/uploads/upload_ff3d1ea3c6c4f3ffb01e90b93314abfc.png" alt="Description of the image" width="500" height="450">

# 知识图谱概念设计文档:

## 系统概述

系统用于分析和展示课程之间的依赖关系以及课程内部的知识点结构。该系统将支持多种用户交互，包括课程查询、知识点探索、学习路径定制等功能。

## 主要实体和关系定义

* 课程（Course）：存储课程的基本信息，如课程名称、编码、学分和课时等。
* 知识点（KnowledgePoint）：描述课程中包含的具体知识点。
* 先修关系（Prerequisite）：表示一门课程是另一门课程的先决条件。
* 用户（User）：系统的使用者，包括学生、教师.
* 交互（Interaction）：用户与系统之间的互动记录，如查询、更新和反馈。

## E-R图设计

以下是系统主要实体及其关系的E-R图:


<img src="https://notes.sjtu.edu.cn/uploads/upload_46bc623646185a2e5481201842b01d7e.png" alt="Description of the image" width="300" height="500">


## 数据流图更新

根据E-R图和系统需求，更新数据流图.


<img src="https://notes.sjtu.edu.cn/uploads/upload_c581b75aaf5c9e0911b17d6ab963eadb.png" alt="Description of the image" width="200" height="400">


## 数据字典详细化:

* 课程（Course）：包括课程名称（name，字符串）、课程代码（code，字符串）、学分（credits，浮点数）和课时（hours，整数）。
* 知识点（KnowledgePoint）：包括名称（name，字符串）和描述（description，字符串）。
* 交互（Interaction）：记录用户与系统的每次交互，关联到具体的课程或查询。



# 知识图谱逻辑设计文档

## 从E-R图到关系模型的转换

以下是E-R组件转换成关系模型的详细步骤：
实体转换：

    课程（Course）：
        课程名称
        课程代码 (主键)
        学分
        课时

    知识点（KnowledgePoint）：
        知识点ID（主键）
        名称
        描述
        课程代码（外键，连接到课程）

    用户（User）：
        用户ID（主键）
        用户名
        角色

关系转换：

    先修关系（Prerequisite）：
        先修ID（主键）
        起始课程代码（外键）
        目标课程代码（外键）

    学习路径（LearningPath）：
        路径ID（主键）
        用户ID（外键）
        路径描述

    交互（Interaction）：
        交互ID（主键）
        用户ID（外键）
        日期
        类型
        课程代码（外键）


系统结构图:




<img src="https://notes.sjtu.edu.cn/uploads/upload_11e6e5ccf77804cc6ce3b49cb7d7ecc9.png" alt="Description of the image" width="200" height="800">

## 数据字典更新

为进一步明确各数据表及字段的详细说明，需要更新数据字典，包括字段类型、可能的值以及字段之间的关系。

课程（Course）：
* 课程名称：字符串，描述课程的名字。
* 课程代码：字符串，课程的唯一代码。
* 学分：浮点数，课程的学分。
* 课时：整型，课程的总课时。

知识点（KnowledgePoint）：
* 知识点ID：整型，唯一标识一个知识点。
* 名称：字符串，知识点的名称。
* 描述：字符串，知识点的详细描述。
* 课程ID：整型，关联的课程ID。

用户（User）：
* 用户ID：整型，唯一标识一个用户。
* 用户名：字符串，用户的登录名。
* 角色：字符串，用户的角色（如学生、教师）。



# Neo4j物理设计文档

## 存储结构

Neo4j使用自定义的存储引擎来优化图数据的存储和查询。其物理存储结构主要包括以下几个部分：

* 节点存储（Node Store）：节点存储文件包含了所有节点的基本信息，例如节点的标签、属性等。每个节点分配一个唯一的ID作为索引。

* 关系存储（Relationship Store）：关系存储文件记录了节点之间的所有关系，包括关系类型、关联节点的ID以及关系属性。

* 属性存储（Property Store）：属性存储文件用于存放节点和关系的属性值，如数值、字符串等。

* 索引文件（Index Store）：Neo4j支持对节点和关系的属性建立索引以加快查询速度，索引文件存储了这些索引信息。

## 数据访问与索引机制

Neo4j的查询效率高度依赖其索引机制。Neo4j支持两种类型的索引：

* 标签索引：用于快速查找带有特定标签的节点。

* 属性索引：用于基于属性值快速查找节点或关系。

使用Cypher查询语言，开发者可以轻松指定使用哪些索引来优化查询，从而提高查询的响应速度。


## 数据传输图

以下是neo4j数据传输图，展示了在Neo4j中数据从存储到最终用户的传输流程：



<img src="https://notes.sjtu.edu.cn/uploads/upload_18ed9fdfb2a99d28cf4a45146d378101.png" alt="Description of the image" width="800" height="100">

## 性能优化措施

为了提高系统性能和查询响应速度，我们采取了以下措施：

* 预热缓存：在系统启动时预加载常用的节点和关系到内存中。

* 查询优化：对Cypher查询进行优化，避免全图扫描，利用索引加速查找。

* 硬件优化：部署在高性能的SSD上，以减少数据访问延迟。

通过这些物理设计和优化措施，Neo4j能够提供高效且可扩展的图数据管理，适用于复杂的知识图谱应用场景。


    
# 知识图谱项目管理与开发
## 使用到的开源仓库:

1. https://github.com/neo4j-examples/movies-python-bolt: 使用flask/FastAPI和d3.js,neo4j搭建的电影数据库
2. https://github.com/niterain/neo4j-instance: 操纵neo4j数据库的实用工具库
3. https://github.com/neo4j/neo4j-python-driver: neo4j驱动程序
4. https://github.com/ggerganov/llama.cpp: LLM inference工具
5. https://github.com/tiangolo/fastapi: 一个现代、快速（高性能）的网络框架，用于基于标准 Python 类型提示使用 Python 构建应用程序接口。
6. https://github.com/fxsjy/jieba: 中文分词工具



## 项目架构:


知识图谱的构建围绕一个多维度、多层次的数据处理流水线展开，该流水线融合了文本的预处理、分词、语义分析、大型语言模型推理以及知识图谱的构建与维护等多个关键技术组件。在设计过程中，我对每一个组件进行了精心挑选和优化配置，以保证整个文本处理流程的高效性和准确性。这不仅包括对中文文本进行深度的分词和语义解析，还涉及到使用先进的自然语言处理模型（如LLM）来推理和生成符合neo4j命令格式的图谱数据。

为了进一步提升系统处理复杂查询的能力，我将整个流水线进行有效的分工和隔离，同时也考虑了数据的可扩展性和可维护性，采用模块化的设计理念，使得每个组件都可以在不影响其他部分的基础上进行独立的升级和优化。

通过这样的系统架构设计，我不仅能够确保文本数据从输入到处理再到输出的每一个步骤都能够高效、准确地执行，还能够为用户提供一个强大而灵活的框架，支持他们对课程内容进行深入的查询和分析。

流程图:

![](https://notes.sjtu.edu.cn/uploads/upload_46782f8f2e069a127c4fc254b28249c0.png)


## 数据处理流水线


### 文本提取与分段:

1. 输入阶段：
整个处理流程的起点是从先前环节获得的文本文件中提取信息。这些文本文件主要以中文撰写，包含了诸多教学课程的详细描述以及相关教学资料。这些文件源自上游任务，其内容涵盖了从课程大纲,具体教学目标,课程公告,课程文档等多个维度，为后续的文本处理和知识图谱构建提供了丰富的数据基础。

2. 处理阶段：
在文本处理阶段，我采用了jieba分词工具进行中文文本的分割。

3. 分类阶段：
经过精确的分词后，我将文本中的词汇按照其所属的课程内容进行分类整理。例如，操作系统（OS）、大学物理一（University-physics）、计算机科学课程（CS1604, CS1605）等，每一类课程都根据其特定的教学内容和目标进行独立分类。这种分类不仅基于课程名称，还深入到课程内容的具体特点，如理论侧重、实践操作等，以确保后续生成的知识图谱在精确性和实用性上都能达到最优状态。通过这样的精细化管理，每个课程相关的文本数据都被有序地组织起来，便于进行更深层次的分析和应用。

此外，这一阶段的工作还包括对分词结果的进一步校验和优化，确保从源文本中提取的信息能够无缝对接到下一阶段的语言模型推理和知识图谱的构建过程中，从而形成一个从文本提取到知识应用的闭环处理流程。

### LLM推理:

1. 处理器配置与调用：
在本项目中，LLM的推理是通过llama.cpp项目实现的。我选择了 70b-llama3-chat gguf模型，这个LLM专为处理和生成复杂的文本数据而设计。通过该模型，我能够处理大量的分词结果，并转化为具有实际应用价值的结构化数据。llama.cpp项目不仅提供了模型调用的接口，还优化了数据输入和输出流程，确保语言模型可以在高效和稳定的环境中运行。

2. 推理过程：
在推理过程中，通过jieba分词工具处理后的文本数据将作为输入，输入到LLM中。这些数据包含了从原始文本中提取的关键词汇和词组。70b-llama3-chat gguf模型将这些输入分析并理解其深层语义，然后生成符合Neo4j图数据库命令格式的输出。这意味着模型不仅仅是在进行文本生成，更是在进行逻辑推理和结构化转换，直接输出可以被图数据库理解和执行的命令。

3. 校正与后处理：
由于自动推理过程可能存在不可避免的误差，例如格式错误或语义不准确等问题，我设计了一套手动过滤和post-processing工具来进行校正。这些工具包括自定义的脚本和程序，能够对LLM的输出结果进行细致的审查和修改。校正过程中，我特别关注保持数据的一致性和准确性，确保每一条生成的Neo4j命令都严格符合图数据库的操作规范。


LLAMA3:使用的prompt:
```
<|begin_of_text|><|start_header_id|>system<|end_header_id|>   
You are a helpful and smart neo4j developer and also a person with expertise in a wide range of domains who answers yser queries with accurate responses.
<|eot_id|><|start_header_id|>user<|end_header_id|>                         
For the following text, please extract the entities and relationships
(in elegant chinese) between these entities (if has one) and 
then return the extracted entities and relationships using neo4j command format. The text is : {text}  
Just return the required template, keep your answer as simple and concise as possible, leave out any explanations and descriptions. 
<|eot_id|><|start_header_id|>assistant<|end_header_id|>
```
运行llama.cpp的参数和命令:
```shell
./main -ngl 32 -m ./pretrained_checkpoints/Meta-Llama-3-70B-Instruct-Q4_K_M.gguf --color -c 4096 --temp 0.7 --repeat_penalty 1.1. --n-predict -1 -p $prompt 
```


### 知识图谱构建与存储

在从LLM模型中提取完成的实体与关系数据，我将其按照课程分类进行有序存储。每个课程相关的数据被细致地保存在磁盘上的特定位置，以便于系统对这些数据进行高效的读取和检索。这种按课程细分的存储策略，不仅有助于维护数据的结构化和可查询性，也便于在未来进行数据的更新与维护工作。

1. 多实例管理的复杂性及其解决方案：
由于Neo4j社区版的使用限制，我面临着只能访问单一数据库的技术挑战。为了突破这一限制，我采取了创新的多实例管理策略。首先，通过专门的工具从官方网站下载Neo4j的执行文件，然后对这些文件的配置进行修改，使得我能够启动多个Neo4j实例，每个实例监听不同的端口。这种方法不仅有效地扩展了系统的数据处理能力，还增强了数据操作的灵活性和系统的可扩展性。

通过修改配置文件，我能够详细设定每个实例的运行参数，如内存使用限制、并发连接数、以及数据同步策略等，确保每个实例都能在最优的条件下运行，从而提升整个系统的性能和稳定性。此外，这种多实例运行方式还允许我针对不同的用户需求和数据安全需求，将特定课程或数据类型隔离在不同的数据库实例中，从而在提升服务质量的同时，增加数据安全性。

### 知识图谱交互框架:

1. 技术选型与架构设计：
在构建知识图谱交互框架时，我选择了FastAPI框架，这是一种现代、快速（高性能）的Web框架，用于构建API与Web应用程序。FastAPI支持异步编程模型，能够处理大量并发请求，这对于数据密集型的操作如知识图谱查询尤为重要。此外，该框架提供了自动交互文档，极大简化了前后端开发者的协作。后端通过高效的Neo4j驱动与数据库进行交互，这种驱动支持通过Cypher查询语言进行高效的图数据操作，确保了数据查询与更新的速度和准确性。

2. 功能实现的深度整合：
系统功能覆盖了增删查改（CRUD）操作。通过FastAPI实现的接口，用户可以方便地执行对知识图谱中的实体和关系的查询、更新、添加和删除操作。特别地，系统还提供了查看特定课程的有向无环图（DAG）关系和实体的功能，这对于理解课程间的依赖和结构具有重要意义。例如，通过特定API端点，用户可以直接查询到课程的先修关系图，从而得到课程结构的直观表示。

3. API服务与端点设计：
我设计了一系列的API端点，以支持各种数据操作和查询需求。例如，/dag/courses端点允许用户查询所有课程的先修关系图的实体，而/course/entities/{title}和/course/rels/{title}端点则提供了搜索指定课程的实体和关系的功能。这些API端点的设计考虑了易用性和功能性，确保用户能够快速而准确地获取所需数据。详细的API文档和示例使得开发者可以轻松理解和使用这些接口，促进了系统的开放性和可扩展性。

# 知识图谱在我们的应用中发挥的作用:

## 课程先修关系DAG图:
- 展示课程之间的先修后续关系。(DAG)
- 通过箭头和线条表示课程之间的依赖性，帮助学生规划学习路径。
- 通过树状图或思维导图的形式，帮助学生理解课程内容的组织结构。

## 跨课程知识点关联图谱:
- 展示不同课程中相互关联的知识点。
- 通过网络图的形式，揭示不同课程间的交叉和互补，促进跨学科学习。

## 学习进度跟踪图谱:
- 根据学生的学习行为和完成情况，动态生成个人学习路径图。
- 通过进度条或时间线的形式，展示学生的学习进度和成就。


# 知识图谱项目API说明:

[详细说明](https://github.com/Learner209/neo4j-courses/blob/CRUD/api_specification.md)

# 知识图谱相关代码和可视化展示:

[代码&&可视化](https://github.com/Learner209/neo4j-courses/blob/CRUD/code_example.md)

# 开发进度:

<img src="https://notes.sjtu.edu.cn/uploads/upload_5d512bd66d5964a5c61763dc438b9971.png" alt="知识图谱后端开发时间线" height=300, width=550>







详细阶段描述:

- 需求收集与分析（第8周初）: 收集业务和技术需求，进行初步分析，确定项目范围和目标。
- 技术选型与工具准备（第8周末至第9周）: 确定使用的技术栈和工具，如Neo4j, FastAPI等，并准备开发环境。
- 概念验证与设计审查（第8周末至第9周）: 对初步设计进行概念验证，确保设计满足所有业务需求，并进行设计审查。
- 数据模型设计（第10周初）: 设计详细的数据模型和图结构，包括节点和边的定义。
- 系统架构设计（第10周末至第11周初）: 设计系统的整体架构，包括前后端分离和服务的模块化。
- 数据库架构实现（第11周末至第12周初）: 实现图数据库的结构，包括节点和关系的创建。
- API开发（第12周中至第13周初）: 开发后端API，支持前端数据交互和业务逻辑处理。
- 数据导入与验证（第14周初）: 导入初始数据并进行验证，确保数据的正确性和完整性。
- 数据流管理与优化（第14周中）: 管理数据流和优化数据处理过程，提高系统性能。
- 系统集成测试（第14周末）: 进行全面的系统测试，确保各个模块的正常运作和数据的准确性。
- 性能优化与调整（第15周初）: 根据测试结果进行性能优化，调整系统配置以满足性能需求。
- 部署与上线（第15周中）: 完成系统部署，并正式上线。
- 系统迭代与优化（第15周末）: 根据用户反馈进行系统迭代和功能优化，确保系统的持续改进和更新。



注:因为知识图谱我们采用的是neo4j,所以上述的E-R图及其转换作为概念存在,实际的存储结构和组织方式由neo4j底层决定.

